{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ctrl-freeq","text":"<p>Ctrl-freeq is a numerical framework for the design of quantum gates and pulses via optimal control theory. The control pulse optimization problem is formulated and solved using automatic differentiation, as provided by PyTorch, and the resulting software supports single- and multi-qubit systems with configurable Hamiltonians, inter-qubit coupling types, and robustness to parameter uncertainties.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>The framework provides access to a comprehensive suite of optimization algorithms, comprising nine gradient-based methods available through the pytorch-minimize library and ten additional optimizers from the Qiskit ecosystem. Quantum systems of varying complexity are supported, ranging from single-qubit configurations to multi-qubit architectures with configurable inter-qubit coupling of the Ising (Z), exchange (XY), or Heisenberg (XYZ) type.</p> <p>Robustness to experimental imperfections is incorporated through the specification of detuning and Rabi frequency uncertainties, allowing the optimizer to find pulses that are tolerant to parameter variations. Open quantum systems subject to decoherence may be modelled via the Lindblad master equation, with support for amplitude damping (T1) and pure dephasing (T2) relaxation channels on a per-qubit basis. The waveform parameterization is flexible, supporting Chebyshev, Fourier, and polynomial basis functions in Cartesian or polar modes.</p> <p>GPU acceleration is available via the CUDA backend of PyTorch, with automatic fallback to CPU execution when CUDA is not present. Interactive dashboards, combining Matplotlib and Plotly visualizations, are generated as standalone HTML files for analysis and sharing. Two complementary interfaces are provided: a programmatic Python API and a Tkinter-based graphical user interface, accessible via the <code>freeq-gui</code> command.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from ctrl_freeq.api import load_single_qubit_config\n\n# Load a built-in single-qubit configuration\napi = load_single_qubit_config()\n\n# Run optimization\nsolution = api.run_optimization()\n\n# Check results\nprint(f\"Final fidelity: {api.parameters.final_fidelity}\")\n</code></pre>"},{"location":"#start-here","title":"Start Here","text":"<ul> <li>Install ctrl-freeq: <code>Installation</code></li> <li>Run from Python: <code>API</code></li> <li>Configure runs interactively: <code>GUI</code></li> <li>Learn about algorithms, parameters, and CPU/GPU support: <code>Optimization</code></li> <li>View and export analysis dashboards: <code>Dashboard</code></li> </ul>"},{"location":"#license","title":"License","text":"<p>Apache License 2.0. See <code>LICENSE</code>.</p>"},{"location":"api/","title":"API Reference","text":"<p>A high-level Python API is provided for the programmatic execution of quantum control optimizations. The principal interface is the <code>CtrlFreeQAPI</code> class, defined in the <code>ctrl_freeq.api</code> module, which encapsulates the complete workflow from configuration loading through optimization to result retrieval.</p>"},{"location":"api/#quick-start","title":"Quick Start","text":"<pre><code>from ctrl_freeq.api import CtrlFreeQAPI, load_single_qubit_config\n\n# Load a built-in example configuration\napi = load_single_qubit_config()\n\n# View configuration summary\nprint(api.get_config_summary())\n\n# Run optimization (returns optimized pulse parameters as a torch.Tensor)\nsolution = api.run_optimization()\n\n# Access results stored on the parameters object\nprint(f\"Final fidelity: {api.parameters.final_fidelity}\")\nprint(f\"Iterations: {api.parameters.iterations}\")\n</code></pre>"},{"location":"api/#ctrlfreeqapi-class","title":"CtrlFreeQAPI Class","text":"<p>The <code>CtrlFreeQAPI</code> class serves as the primary interface for interacting with the ctrl-freeq optimization framework.</p>"},{"location":"api/#constructor","title":"Constructor","text":"<pre><code>CtrlFreeQAPI(config: Union[str, Path, Dict[str, Any]])\n</code></pre> <p>An API instance may be created from a path to a JSON configuration file (provided as a string or <code>Path</code> object) or from a dictionary containing the configuration parameters directly.</p> <p>Parameters:</p> Parameter Type Description <code>config</code> <code>str</code>, <code>Path</code>, or <code>dict</code> Configuration source <p>Examples:</p> From JSON fileFrom dictionaryFrom built-in config <pre><code>from ctrl_freeq.api import CtrlFreeQAPI\n\napi = CtrlFreeQAPI(\"path/to/config.json\")\n</code></pre> <pre><code>from ctrl_freeq.api import CtrlFreeQAPI\n\nconfig = {\n    \"qubits\": [\"q1\"],\n    \"compute_resource\": \"cpu\",\n    \"parameters\": {\n        \"Delta\": [0.0],\n        \"Omega_R_max\": [10000.0],\n        \"pulse_duration\": [0.001],\n        \"point_in_pulse\": [100],\n        # ... other parameters\n    },\n    \"initial_states\": [[\"Z\"]],\n    \"target_states\": {\"Axis\": [[\"-Z\"]]},\n    \"optimization\": {\n        \"space\": \"hilbert\",\n        \"algorithm\": \"bfgs\",\n        \"max_iter\": 100,\n        \"targ_fid\": 0.99\n    }\n}\n\napi = CtrlFreeQAPI(config)\n</code></pre> <pre><code>from ctrl_freeq.api import load_single_qubit_config\n\napi = load_single_qubit_config()\n</code></pre>"},{"location":"api/#methods","title":"Methods","text":""},{"location":"api/#run_optimization","title":"<code>run_optimization()</code>","text":"<p>Executes the quantum control optimization with the loaded configuration.</p> <pre><code>solution = api.run_optimization()\n</code></pre> <p>Returns: <code>torch.Tensor</code> \u2014 The optimized pulse parameters.</p> <p>Upon completion of the optimization, the following attributes are stored on <code>api.parameters</code>:</p> Attribute Type Description <code>final_fidelity</code> <code>float</code> Final achieved fidelity <code>iterations</code> <code>int</code> Number of iterations performed <code>fidelity_history</code> <code>list[float]</code> Fidelity at each iteration <p>Example:</p> <pre><code>from ctrl_freeq.api import load_single_qubit_config\n\napi = load_single_qubit_config()\nsolution = api.run_optimization()\n\n# Access results from the parameters object\nprint(f\"Final fidelity: {api.parameters.final_fidelity}\")\nprint(f\"Iterations: {api.parameters.iterations}\")\nprint(f\"Fidelity history: {api.parameters.fidelity_history}\")\n</code></pre>"},{"location":"api/#get_config_summary","title":"<code>get_config_summary()</code>","text":"<p>Returns a human-readable summary of the current configuration.</p> <pre><code>summary = api.get_config_summary()\n</code></pre> <p>Returns: <code>str</code> \u2014 A formatted string containing the number of qubits, optimization space (Hilbert/Liouville), algorithm name, maximum iterations, target fidelity, and the initial and target states.</p> <p>Example:</p> <pre><code>from ctrl_freeq.api import load_two_qubit_config\n\napi = load_two_qubit_config()\nprint(api.get_config_summary())\n</code></pre> <p>Output: <pre><code>Number of qubits: 2\nOptimization space: hilbert\nAlgorithm: newton-cg\nMax iterations: 1000\nTarget fidelity: 0.999\nInitial states: [['Z', '-Z']]\nTarget Gate: ['CNOT']\n</code></pre></p>"},{"location":"api/#update_parameterparameter_path-value","title":"<code>update_parameter(parameter_path, value)</code>","text":"<p>Updates a specific parameter in the configuration and reinitializes the internal state accordingly.</p> <pre><code>api.update_parameter(parameter_path: str, value: Any)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>parameter_path</code> <code>str</code> Dot-separated path to the parameter <code>value</code> <code>Any</code> New value for the parameter <p>Raises: <code>KeyError</code> if the parameter path is not found.</p> <p>Example:</p> <pre><code>from ctrl_freeq.api import load_single_qubit_config\n\napi = load_single_qubit_config()\n\n# Update optimization settings\napi.update_parameter(\"optimization.max_iter\", 200)\napi.update_parameter(\"optimization.algorithm\", \"qiskit-cobyla\")\napi.update_parameter(\"optimization.targ_fid\", 0.999)\n\n# Update pulse parameters\napi.update_parameter(\"parameters.pulse_duration\", [0.002])\n\n# Run with updated configuration\nsolution = api.run_optimization()\n</code></pre> <p>Common parameter paths:</p> Path Description <code>optimization.algorithm</code> Optimization algorithm <code>optimization.max_iter</code> Maximum iterations <code>optimization.targ_fid</code> Target fidelity <code>optimization.space</code> <code>hilbert</code> or <code>liouville</code> <code>optimization.dissipation_mode</code> <code>non-dissipative</code> or <code>dissipative</code> <code>parameters.Delta</code> Detuning (Hz) <code>parameters.Omega_R_max</code> Maximum Rabi frequency (Hz) <code>parameters.pulse_duration</code> Pulse duration (seconds) <code>parameters.point_in_pulse</code> Discretization points <code>parameters.T1</code> Amplitude damping time (seconds) <code>parameters.T2</code> Pure dephasing time (seconds) <code>compute_resource</code> <code>cpu</code> or <code>gpu</code>"},{"location":"api/#properties","title":"Properties","text":""},{"location":"api/#config","title":"<code>config</code>","text":"<p>The raw configuration dictionary.</p> <pre><code>raw_config = api.config\n</code></pre>"},{"location":"api/#config_path","title":"<code>config_path</code>","text":"<p>The path to the configuration file, if the instance was created from a file; otherwise <code>None</code>.</p> <pre><code>path = api.config_path\n</code></pre>"},{"location":"api/#parameters","title":"<code>parameters</code>","text":"<p>The initialized parameter object used internally by the optimization engine.</p> <pre><code>params = api.parameters\n</code></pre>"},{"location":"api/#helper-functions","title":"Helper Functions","text":""},{"location":"api/#run_from_configconfig","title":"<code>run_from_config(config)</code>","text":"<p>A convenience function that creates a <code>CtrlFreeQAPI</code> instance and executes the optimization in a single call.</p> <pre><code>from ctrl_freeq.api import run_from_config\n\nsolution = run_from_config(\"path/to/config.json\")\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>config</code> <code>str</code>, <code>Path</code>, or <code>dict</code> Configuration source <p>Returns: <code>torch.Tensor</code> \u2014 The optimized pulse parameters.</p> <p>Example with dictionary:</p> <pre><code>from ctrl_freeq.api import run_from_config\n\nsolution = run_from_config({\n    \"qubits\": [\"q1\"],\n    \"compute_resource\": \"cpu\",\n    \"parameters\": { ... },\n    \"initial_states\": [[\"Z\"]],\n    \"target_states\": {\"Axis\": [[\"-Z\"]]},\n    \"optimization\": {\n        \"space\": \"hilbert\",\n        \"algorithm\": \"bfgs\",\n        \"max_iter\": 100,\n        \"targ_fid\": 0.99\n    }\n})\n</code></pre>"},{"location":"api/#load_configconfig_path","title":"<code>load_config(config_path)</code>","text":"<p>Loads a JSON configuration file and returns a <code>CtrlFreeQAPI</code> instance.</p> <pre><code>from ctrl_freeq.api import load_config\n\napi = load_config(\"path/to/config.json\")\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>config_path</code> <code>str</code> or <code>Path</code> Path to JSON configuration file <p>Returns: <code>CtrlFreeQAPI</code> instance.</p>"},{"location":"api/#built-in-example-configurations","title":"Built-in Example Configurations","text":"<p>Several pre-configured examples are bundled with the package for common use cases. These correspond to JSON files located under <code>src/ctrl_freeq/data/json_input/</code>.</p>"},{"location":"api/#single-qubit-configurations","title":"Single-Qubit Configurations","text":""},{"location":"api/#load_single_qubit_config","title":"<code>load_single_qubit_config()</code>","text":"<p>A basic single-qubit optimization configuration.</p> <pre><code>from ctrl_freeq.api import load_single_qubit_config\n\napi = load_single_qubit_config()\nsolution = api.run_optimization()\n</code></pre>"},{"location":"api/#load_single_qubit_multiple_config","title":"<code>load_single_qubit_multiple_config()</code>","text":"<p>A single-qubit configuration with multiple initial/target state pairs for universal rotation design.</p> <pre><code>from ctrl_freeq.api import load_single_qubit_multiple_config\n\napi = load_single_qubit_multiple_config()\n</code></pre>"},{"location":"api/#load_single_qubit_polar_phase_config","title":"<code>load_single_qubit_polar_phase_config()</code>","text":"<p>A single-qubit configuration using the polar/phase waveform mode.</p> <pre><code>from ctrl_freeq.api import load_single_qubit_polar_phase_config\n\napi = load_single_qubit_polar_phase_config()\n</code></pre>"},{"location":"api/#load_single_qubit_dissipative_config","title":"<code>load_single_qubit_dissipative_config()</code>","text":"<p>A single-qubit configuration with dissipative (Lindblad) dynamics enabled. The evolution includes amplitude damping (T1 = 1 ms) and pure dephasing (T2 = 500 \u03bcs), and the optimization is performed in Liouville (density matrix) space.</p> <pre><code>from ctrl_freeq.api import load_single_qubit_dissipative_config\n\napi = load_single_qubit_dissipative_config()\n</code></pre>"},{"location":"api/#two-qubit-configurations","title":"Two-Qubit Configurations","text":""},{"location":"api/#load_two_qubit_config","title":"<code>load_two_qubit_config()</code>","text":"<p>A basic two-qubit optimization configuration with inter-qubit coupling.</p> <pre><code>from ctrl_freeq.api import load_two_qubit_config\n\napi = load_two_qubit_config()\n</code></pre>"},{"location":"api/#load_two_qubit_multiple_config","title":"<code>load_two_qubit_multiple_config()</code>","text":"<p>A two-qubit configuration with multiple initial/target state pairs.</p> <pre><code>from ctrl_freeq.api import load_two_qubit_multiple_config\n\napi = load_two_qubit_multiple_config()\n</code></pre>"},{"location":"api/#load_two_qubit_polar_phase_config","title":"<code>load_two_qubit_polar_phase_config()</code>","text":"<p>A two-qubit configuration using the polar/phase waveform mode.</p> <pre><code>from ctrl_freeq.api import load_two_qubit_polar_phase_config\n\napi = load_two_qubit_polar_phase_config()\n</code></pre>"},{"location":"api/#multi-qubit-configurations","title":"Multi-Qubit Configurations","text":""},{"location":"api/#load_four_qubit_polar_phase_config","title":"<code>load_four_qubit_polar_phase_config()</code>","text":"<p>A four-qubit optimization configuration using the polar/phase waveform mode.</p> <pre><code>from ctrl_freeq.api import load_four_qubit_polar_phase_config\n\napi = load_four_qubit_polar_phase_config()\n</code></pre>"},{"location":"api/#complete-workflow-example","title":"Complete Workflow Example","text":"<p>The following example illustrates a complete optimization workflow, from configuration loading through parameter customization, optimization, and result visualization:</p> <pre><code>from ctrl_freeq.api import CtrlFreeQAPI, load_single_qubit_config\nfrom ctrl_freeq.visualisation.plotter import process_and_plot\nfrom ctrl_freeq.visualisation.dashboard import create_dashboard\nfrom datetime import datetime\n\n# 1. Load configuration\napi = load_single_qubit_config()\n\n# 2. Customize parameters\napi.update_parameter(\"optimization.algorithm\", \"qiskit-cobyla\")\napi.update_parameter(\"optimization.max_iter\", 150)\napi.update_parameter(\"optimization.targ_fid\", 0.995)\n\n# 3. Review configuration\nprint(api.get_config_summary())\n\n# 4. Run optimization\nsolution = api.run_optimization()\n\n# 5. Check results\nprint(f\"Final fidelity: {api.parameters.final_fidelity}\")\nprint(f\"Iterations: {api.parameters.iterations}\")\n\n# 6. Generate plots\n# process_and_plot takes the solution tensor and the parameters object\nwaveforms, figures = process_and_plot(solution, api.parameters, save_plots=True)\n\n# 7. Create dashboard (pass parameters for a richer sidebar)\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\ndashboard_path = create_dashboard(figures, timestamp, parameters=api.parameters)\nprint(f\"Dashboard saved to: {dashboard_path}\")\n</code></pre>"},{"location":"api/#dissipative-lindblad-workflow-example","title":"Dissipative (Lindblad) Workflow Example","text":"<p>The following example demonstrates a complete optimization workflow for an open quantum system subject to amplitude damping and pure dephasing. The Lindblad master equation is employed to model the dissipative channels, and the optimization is performed in Liouville (density matrix) space.</p> From built-in configFrom dictionary <pre><code>from ctrl_freeq.api import load_single_qubit_dissipative_config\nfrom ctrl_freeq.visualisation.plotter import process_and_plot\n\n# Load the pre-configured dissipative example\napi = load_single_qubit_dissipative_config()\n\n# Review configuration (includes T1/T2 information)\nprint(api.get_config_summary())\n\n# Run optimization\nsolution = api.run_optimization()\n\n# Check results\nprint(f\"Final fidelity: {api.parameters.final_fidelity}\")\nprint(f\"Iterations: {api.parameters.iterations}\")\n\n# Generate plots\nwaveforms = process_and_plot(solution, api.parameters, show_plots=True)\n</code></pre> <pre><code>from ctrl_freeq.api import CtrlFreeQAPI\nfrom ctrl_freeq.visualisation.plotter import process_and_plot\n\nconfig = {\n    \"qubits\": [\"q1\"],\n    \"compute_resource\": \"cpu\",\n    \"parameters\": {\n        \"Delta\": [10000000.0],\n        \"Omega_R_max\": [40000000.0],\n        \"pulse_duration\": [2e-07],\n        \"point_in_pulse\": [100],\n        \"wf_type\": [\"cheb\"],\n        \"wf_mode\": [\"cart\"],\n        \"amplitude_envelope\": [\"gn\"],\n        \"amplitude_order\": [1],\n        \"coverage\": [\"broadband\"],\n        \"sw\": [5000000.0],\n        \"pulse_offset\": [0.0],\n        \"pulse_bandwidth\": [500000.0],\n        \"ratio_factor\": [0.5],\n        \"sigma_Delta\": [0.0],\n        \"sigma_Omega_R_max\": [0.0],\n        \"profile_order\": [2],\n        \"n_para\": [16],\n        \"J\": [[0.0]],\n        \"T1\": [0.001],           # 1 ms amplitude damping\n        \"T2\": [0.0005]           # 500 \u03bcs pure dephasing\n    },\n    \"initial_states\": [[\"Z\"]],\n    \"target_states\": {\"Axis\": [[\"-Z\"]]},\n    \"optimization\": {\n        \"space\": \"liouville\",\n        \"dissipation_mode\": \"dissipative\",\n        \"H0_snapshots\": 100,\n        \"Omega_R_snapshots\": 1,\n        \"algorithm\": \"qiskit-cobyla\",\n        \"max_iter\": 1000,\n        \"targ_fid\": 0.99\n    }\n}\n\napi = CtrlFreeQAPI(config)\nsolution = api.run_optimization()\nprint(f\"Final fidelity: {api.parameters.final_fidelity}\")\n</code></pre> <p>Dissipation Requirements</p> <p>When <code>dissipation_mode</code> is set to <code>\"dissipative\"</code>, the following conditions must be satisfied:</p> <ul> <li>The optimization <code>space</code> must be <code>\"liouville\"</code> (density matrix mode)</li> <li>Per-qubit <code>T1</code> and <code>T2</code> values must be provided in the <code>parameters</code> section</li> <li>The physical constraint $T_2 \\leq 2 T_1$ must hold for each qubit</li> </ul> <p>For a detailed description of the dissipation parameters, see Optimization \u2192 Parameters \u2192 Dissipation Parameters.</p>"},{"location":"api/#configuration-schema","title":"Configuration Schema","text":"<p>For a detailed treatment of all configuration parameters, the reader is referred to:</p> <ul> <li>Optimization Parameters \u2014 Full parameter reference</li> <li>Algorithms \u2014 Available optimization algorithms</li> <li>Compute (CPU/GPU) \u2014 CPU and GPU configuration</li> </ul>"},{"location":"api/#error-handling","title":"Error Handling","text":"<pre><code>from ctrl_freeq.api import CtrlFreeQAPI\n\ntry:\n    api = CtrlFreeQAPI(\"nonexistent.json\")\nexcept FileNotFoundError as e:\n    print(f\"Configuration file not found: {e}\")\n\ntry:\n    api.update_parameter(\"invalid.path\", 100)\nexcept KeyError as e:\n    print(f\"Invalid parameter path: {e}\")\n</code></pre>"},{"location":"api/#next-steps","title":"Next Steps","text":"<ul> <li>GUI Guide \u2014 Configure and run optimization interactively</li> <li>Dashboard \u2014 Visualize and export results</li> <li>Optimization Parameters \u2014 Detailed parameter reference</li> </ul>"},{"location":"dashboard/","title":"Dashboard","text":"<p>Ctrl-freeq includes an interactive dashboard facility that consolidates all analysis figures from an optimization run into a single, self-contained HTML file. The dashboard is constructed using Panel and presents the figures in a responsive card grid with a dark theme. Both Matplotlib and Plotly figures are accepted without conversion, and Plotly figures retain their full interactivity in the exported file.</p>"},{"location":"dashboard/#features","title":"Features","text":"<p>The dashboard provides several capabilities that facilitate the review and dissemination of optimization results. All figures are exported to a single standalone HTML file, which can be opened in any web browser without the need for a running server. The responsive two-column card layout adapts to the available screen size, and a clean dark theme is applied for improved readability. Since the entire dashboard is contained in a single file, it may be readily shared with collaborators.</p>"},{"location":"dashboard/#usage","title":"Usage","text":""},{"location":"dashboard/#automatic-generation-recommended","title":"Automatic Generation (Recommended)","text":"<p>When the Save Results button in the GUI is used, a dashboard is automatically generated alongside the saved plots in the <code>results/dashboards/</code> directory.</p>"},{"location":"dashboard/#programmatic-usage","title":"Programmatic Usage","text":"<pre><code>from ctrl_freeq.api import load_single_qubit_config\nfrom ctrl_freeq.visualisation.plotter import process_and_plot\nfrom ctrl_freeq.visualisation.dashboard import create_dashboard\nfrom datetime import datetime\n\n# Run optimization\napi = load_single_qubit_config()\nsolution = api.run_optimization()\n\n# Generate plots and get figures\nwaveforms, figures = process_and_plot(solution, api.parameters, save_plots=False)\n\n# Create dashboard (pass parameters for a richer sidebar with algorithm, fidelity, etc.)\ntimestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\ndashboard_path = create_dashboard(figures, timestamp, parameters=api.parameters)\nprint(f\"Dashboard saved to: {dashboard_path}\")\n</code></pre>"},{"location":"dashboard/#create_dashboard-parameters","title":"<code>create_dashboard</code> Parameters","text":"<pre><code>create_dashboard(figures, timestamp, parameters=None)\n</code></pre> Parameter Type Description <code>figures</code> <code>list</code> List of Matplotlib and/or Plotly figure objects <code>timestamp</code> <code>str</code> Timestamp string for the dashboard filename <code>parameters</code> <code>Initialise</code>, optional Parameters object from the optimization run. When provided, the dashboard sidebar displays algorithm, fidelity target, pulse parameters, and state information. <p>Enriched Sidebar Information</p> <p>When the <code>parameters</code> argument is omitted, the dashboard sidebar displays only the timestamp and figure count. Passing <code>api.parameters</code> populates the sidebar with a comprehensive summary of the optimization and system parameters, which is generally recommended for reproducibility.</p>"},{"location":"dashboard/#demo-function","title":"Demo Function","text":"<p>A sample dashboard may be generated by running the dashboard module directly:</p> <pre><code>python -m ctrl_freeq.visualisation.dashboard\n</code></pre>"},{"location":"dashboard/#example-dashboard","title":"Example Dashboard","text":"<p>An example of the dashboard generated from a single-qubit optimization run is shown below. This is representative of the output produced by clicking Save Results in the GUI or by invoking <code>create_dashboard</code> through the API.</p> <p>View Example Dashboard</p> <p>The dashboard opens in a new tab as a standalone interactive page; Plotly figures may be zoomed, panned, and inspected via hover tooltips.</p>"},{"location":"dashboard/#dashboard-contents","title":"Dashboard Contents","text":"<p>The dashboard typically includes visualizations from the following categories:</p> Category Visualizations Pulse Waveforms IQ plots, amplitude/phase evolution State Evolution History plots, observable dynamics Quantum State Bloch sphere (single qubit), population dynamics Analysis Excitation profiles, fidelity convergence"},{"location":"dashboard/#file-structure","title":"File Structure","text":"<pre><code>ctrl-freeq/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 ctrl_freeq/\n\u2502       \u2514\u2500\u2500 visualisation/\n\u2502           \u251c\u2500\u2500 __init__.py\n\u2502           \u251c\u2500\u2500 dashboard.py          # Dashboard creation module\n\u2502           \u251c\u2500\u2500 plotter.py            # Plotting functions\n\u2502           \u2514\u2500\u2500 plot_settings.py      # Plot configuration\n\u2514\u2500\u2500 results/\n    \u2514\u2500\u2500 dashboards/                   # Generated dashboard HTML files\n        \u2514\u2500\u2500 dashboard_YYYYMMDD_HHMMSS.html\n</code></pre>"},{"location":"dashboard/#troubleshooting","title":"Troubleshooting","text":"<p>Dashboard Not Generating</p> <p>If the dashboard is not being produced, it is advisable to verify that figures are being captured correctly: <pre><code>waveforms, figures = process_and_plot(solution, parameters, save_plots=False)\nprint(f\"Captured {len(figures)} figures\")\n</code></pre></p> <p>Dashboard File Size</p> <p>The HTML file includes all resources inline to ensure portability. Should the file size become prohibitively large, the number of figures or the figure resolution may be reduced accordingly.</p> <p>Figure Rendering Issues</p> <p>For Matplotlib figures, it is recommended to ensure that the <code>tight=True</code> parameter is used. For Plotly figures, the <code>plotly</code> extension should be loaded via <code>pn.extension('plotly')</code>.</p>"},{"location":"dashboard/#next-steps","title":"Next Steps","text":"<ul> <li>GUI Guide \u2014 Configure and run optimization interactively</li> <li>API Reference \u2014 Use ctrl-freeq programmatically</li> <li>Panel Documentation \u2014 Learn more about Panel dashboards</li> </ul>"},{"location":"gui/","title":"GUI Guide","text":"<p>In addition to the programmatic API, ctrl-freeq provides a graphical user interface, implemented using the Tkinter framework, which allows the configuration and execution of quantum control optimizations without the need for writing Python code. The interface exposes the full set of configurable parameters and provides real-time feedback during the optimization process.</p>"},{"location":"gui/#launching-the-gui","title":"Launching the GUI","text":"<p>The GUI may be launched from the command line after installation:</p> <pre><code>freeq-gui\n</code></pre> <p>Alternatively, it may be invoked as a Python module:</p> <pre><code>python -m ctrl_freeq.cli\n</code></pre> <p>First Launch</p> <p>Upon first launch, the GUI opens with a single qubit configured. Additional qubits may be added using the Add Qubit button for multi-qubit optimizations.</p>"},{"location":"gui/#gui-layout","title":"GUI Layout","text":"<p>The interface is organized into five principal sections:</p> Section Purpose Qubit Configuration Per-qubit pulse and system parameters Target Specification Definition of the target quantum state or gate Optimization Settings Algorithm, iterations, and compute options Coupling Controls Inter-qubit coupling (multi-qubit only) Action Buttons Run, Save, and Reset controls"},{"location":"gui/#single-qubit-configuration","title":"Single-Qubit Configuration","text":"The GUI configured for a single-qubit Hadamard gate optimization."},{"location":"gui/#two-qubit-configuration","title":"Two-Qubit Configuration","text":"The GUI configured for a two-qubit CNOT gate optimization with XY coupling. <p>Coupling Controls</p> <p>The Coupling Type and Coupling Constants section appears on the right-hand side of the interface only when two or more qubits are configured.</p>"},{"location":"gui/#configuring-parameters","title":"Configuring Parameters","text":"<p>Each qubit is assigned its own configuration panel. The parameters within each panel are organized into three categories:</p> <ul> <li>System Parameters \u2014 Detuning (\u0394), Rabi frequency (\u03a9_R), and their associated uncertainties</li> <li>Pulse Parameters \u2014 Duration, discretization, sweep rate, and bandwidth</li> <li>Waveform Settings \u2014 Basis type, mode, envelope, and expansion order</li> </ul> <p>A detailed description of all parameters, including their defaults and units, is provided in Optimization \u2192 Parameters.</p>"},{"location":"gui/#target-specification","title":"Target Specification","text":"<p>The Target States Method dropdown determines the method by which the desired final state is specified:</p> Method Description Axis Bloch sphere direction (<code>Z</code>, <code>-Z</code>, <code>X</code>, <code>-X</code>, <code>Y</code>, <code>-Y</code>) Gate Quantum gate (<code>X</code>, <code>H</code>, <code>CNOT</code>, <code>CZ</code>, etc.) Phi/Beta Rotation angles (axis \u03c6 and angle \u03b2) <p>Example \u2014 \u03c0-pulse (inversion):</p> <ul> <li>Initial State: <code>Z</code></li> <li>Target Method: <code>Axis</code></li> <li>Target Axis: <code>-Z</code></li> </ul> <p>A complete description of all target specification options is provided in Optimization \u2192 Parameters \u2192 Target States.</p> <p>Multi-State Optimization</p> <p>For the design of universal rotations or conditional gates, multiple initial/target state pairs may be specified. Comma-separated values are entered in the respective fields (e.g., Initial: <code>X, Y, Z</code>, Target: <code>X, Z, -Y</code>). A detailed treatment of this capability is provided in Multi-State Optimization.</p>"},{"location":"gui/#optimization-settings","title":"Optimization Settings","text":"Setting Description Space <code>hilbert</code> (pure states) or <code>liouville</code> (density matrices) Dissipation <code>non-dissipative</code> (default) or <code>dissipative</code> (Lindblad master equation) Algorithm Optimization algorithm Max Iterations Maximum optimization iterations Target Fidelity Stop when fidelity reaches this value Compute Resource <code>cpu</code> or <code>gpu</code> <p>For guidance on algorithm selection, the reader is referred to Optimization \u2192 Algorithms.</p> <p>For GPU setup instructions, see Optimization \u2192 Compute.</p>"},{"location":"gui/#dissipation-controls","title":"Dissipation Controls","text":"<p>When the Dissipation dropdown is set to <code>dissipative</code>, the interface enables the modelling of open quantum systems via the Lindblad master equation. The following behaviour is activated:</p> <ul> <li>The Space setting is automatically forced to <code>liouville</code> (density matrix mode)</li> <li>Per-qubit T1 and T2 entry fields are revealed in the qubit configuration panel</li> <li>The optimizer employs an Euler operator-splitting scheme, applying a unitary step followed by a Lindblad dissipative step at each time increment</li> </ul> Control Description Units T1 Amplitude damping time constant (energy relaxation) seconds T2 Pure dephasing time constant (phase decoherence) seconds <p>Physical Constraint</p> <p>The values entered must satisfy the physical constraint $T_2 \\leq 2 T_1$ for each qubit. Configurations that violate this bound will produce a validation error.</p> <p>Liouville Space</p> <p>Selecting <code>dissipative</code> mode automatically sets the optimization space to <code>liouville</code>. This is required because dissipative dynamics operate on density matrices rather than pure state vectors. The space selection cannot be changed back to <code>hilbert</code> while <code>dissipative</code> mode is active.</p>"},{"location":"gui/#coupling-controls-multi-qubit","title":"Coupling Controls (Multi-Qubit)","text":"<p>When two or more qubits are configured, a coupling section becomes available:</p> Control Description J_ij Coupling strength between qubit pairs Coupling Type <code>Z</code> (Ising), <code>XY</code> (exchange), or <code>XYZ</code> (Heisenberg) \u03c3 J Coupling uncertainty <p>For a detailed description of the coupling parameters, see Optimization \u2192 Parameters \u2192 Multi-Qubit Coupling.</p>"},{"location":"gui/#action-buttons","title":"Action Buttons","text":""},{"location":"gui/#run","title":"Run","text":"<p>Initiates the optimization with the current settings. Progress information is displayed in the console, and the resulting plots are presented upon completion.</p>"},{"location":"gui/#save","title":"Save","text":"<p>Saves the current configuration to a JSON file. The exported file may subsequently be loaded in the GUI, used with the Python API, or shared with collaborators.</p>"},{"location":"gui/#save-results","title":"Save Results","text":"<p>Upon completion of an optimization run, this button performs the following actions:</p> <ol> <li>All generated plots are saved to <code>results/plots/</code></li> <li>An interactive dashboard HTML file is created in <code>results/dashboards/</code></li> </ol> <p>A detailed description of the dashboard is provided in Dashboard.</p>"},{"location":"gui/#set-defaults","title":"Set Defaults","text":"<p>Resets all parameters to their default values.</p>"},{"location":"gui/#workflow-examples","title":"Workflow Examples","text":""},{"location":"gui/#example-1-single-qubit-pulse","title":"Example 1: Single-Qubit \u03c0-Pulse","text":"<ol> <li>Launch the GUI: <code>freeq-gui</code></li> <li>Set Initial State: <code>Z</code></li> <li>Set Target States Method: <code>Axis</code></li> <li>Set Target Axis: <code>-Z</code></li> <li>Set Algorithm: <code>bfgs</code></li> <li>Click Run</li> </ol>"},{"location":"gui/#example-2-two-qubit-cnot-gate","title":"Example 2: Two-Qubit CNOT Gate","text":"<ol> <li>Launch the GUI: <code>freeq-gui</code></li> <li>Click Add Qubit to add a second qubit</li> <li>Set Target States Method: <code>Gate</code></li> <li>Set Gate: <code>CNOT</code></li> <li>Configure coupling in the Coupling section</li> <li>Click Run</li> </ol>"},{"location":"gui/#example-3-robust-pulse-design","title":"Example 3: Robust Pulse Design","text":"<ol> <li>Configure the basic pulse parameters</li> <li>Set \u03c3\u0394 (Hz): <code>100000</code> (100 kHz uncertainty)</li> <li>Set \u03c3\u03a9_R Max (Hz): <code>50000</code> (50 kHz uncertainty)</li> <li>Set Target Fidelity: <code>0.9999</code></li> <li>Click Run</li> </ol> <p>The optimizer will seek pulses that are robust to the specified parameter uncertainties.</p>"},{"location":"gui/#example-4-dissipative-pulse-open-quantum-system","title":"Example 4: Dissipative \u03c0-Pulse (Open Quantum System)","text":"<ol> <li>Launch the GUI: <code>freeq-gui</code></li> <li>Set Initial State: <code>Z</code></li> <li>Set Target States Method: <code>Axis</code></li> <li>Set Target Axis: <code>-Z</code></li> <li>Set Dissipation: <code>dissipative</code></li> <li>Enter T1: <code>0.001</code> (1 ms)</li> <li>Enter T2: <code>0.0005</code> (500 \u03bcs)</li> <li>Set Algorithm: <code>qiskit-cobyla</code></li> <li>Click Run</li> </ol> <p>The optimizer will design a pulse that achieves the desired inversion while accounting for amplitude damping and dephasing during the pulse.</p>"},{"location":"gui/#example-5-universal-rotation-pulse","title":"Example 5: Universal Rotation Pulse","text":"<ol> <li>Launch the GUI: <code>freeq-gui</code></li> <li>Set Initial State: <code>X, Y, Z</code></li> <li>Set Target States Method: <code>Axis</code></li> <li>Set Target Axis: <code>X, Z, -Y</code></li> <li>Set Algorithm: <code>qiskit-cobyla</code> (recommended for multi-state optimization)</li> <li>Click Run</li> </ol> <p>This procedure designs a single pulse that performs a universal rotation, mapping all three Bloch sphere axes to their specified targets simultaneously. A detailed treatment of multi-state optimization is provided in Multi-State Optimization.</p>"},{"location":"gui/#tips","title":"Tips","text":"<p>Recommended Initial Approach</p> <p>It is generally advisable to begin with the default parameter values and a straightforward target configuration (such as a \u03c0-pulse) in order to verify that the setup is functioning correctly before proceeding to more complex optimization problems.</p> <p>Iteration Count</p> <p>For initial testing, a moderate number of iterations (100\u2013500) is typically sufficient. For production-quality results, the iteration count should be increased to 1000 or more.</p> <p>Memory Usage</p> <p>Multi-qubit systems with a large number of time discretization points can require significant memory. System resources should be monitored when working with large problem sizes.</p>"},{"location":"gui/#troubleshooting","title":"Troubleshooting","text":""},{"location":"gui/#gui-does-not-launch","title":"GUI does not launch","text":"<pre><code># Verify that Tkinter is available\npython -c \"import tkinter; print('Tkinter OK')\"\n\n# Attempt to run directly\npython -m ctrl_freeq.cli\n</code></pre>"},{"location":"gui/#optimization-does-not-converge","title":"Optimization does not converge","text":"<ul> <li>Increase the Max Iterations setting</li> <li>Consider using a different Algorithm (see Algorithms)</li> <li>Reduce the Target Fidelity initially to verify convergence behaviour</li> <li>Ensure that parameter values are physically reasonable</li> </ul>"},{"location":"gui/#plots-do-not-appear","title":"Plots do not appear","text":"<ul> <li>Verify that the matplotlib backend is correctly configured</li> <li>Check the console for error messages</li> <li>As an alternative, save the results rather than viewing them interactively</li> </ul>"},{"location":"gui/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference \u2014 Use ctrl-freeq programmatically</li> <li>Dashboard \u2014 Visualize and export results</li> <li>Optimization Parameters \u2014 Detailed parameter reference</li> <li>Algorithms \u2014 Algorithm details and selection guide</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>In this section, the installation procedure for ctrl-freeq is described. The package may be obtained either from PyPI, where both stable and pre-release versions are published, or directly from the GitHub repository.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11\u20133.13 (required)</li> <li>A working installation of <code>pip</code> or <code>uv</code></li> </ul>"},{"location":"installation/#core-dependencies","title":"Core Dependencies","text":"<p>Ctrl-freeq automatically installs the following dependencies:</p> Package Purpose <code>numpy</code> Numerical computing <code>matplotlib</code> Plotting and visualization <code>torch</code> (PyTorch) Tensor operations and GPU acceleration <code>pytorch-minimize</code> Gradient-based optimization on PyTorch tensors <code>scipy</code> Scientific computing <code>qiskit</code> Quantum computing framework <code>qiskit-algorithms</code> Optimization algorithms <code>plotly</code> Interactive plots <code>kaleido</code> Static figure export <code>panel</code> Dashboard generation <p>Note</p> <p>It should be noted that the PyPI distribution name is <code>ctrl-freeq</code>, which differs from the Python import path <code>ctrl_freeq</code>.</p>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":""},{"location":"installation/#stable-releases","title":"Stable Releases","text":"<p>The latest stable version may be installed via pip:</p> <pre><code>pip install ctrl-freeq\n</code></pre>"},{"location":"installation/#beta-pre-release-versions","title":"Beta (Pre-release) Versions","text":"<p>Pre-releases follow standard Python packaging conventions (PEP 440) and are not installed by default.</p> <p>The latest available pre-release may be installed as follows:</p> <pre><code>pip install --pre ctrl-freeq\n</code></pre> <p>A specific beta version may also be requested:</p> <pre><code>pip install ctrl-freeq==0.1.0b4\n</code></pre> <p>Finding Available Versions</p> <p>All available versions may be viewed on PyPI.</p>"},{"location":"installation/#install-from-github","title":"Install from GitHub","text":""},{"location":"installation/#install-the-latest-commit-from-main","title":"Install the Latest Commit from <code>main</code>","text":"<pre><code>pip install \"ctrl-freeq @ git+https://github.com/mforoozandeh/ctrl-freeq.git\"\n</code></pre>"},{"location":"installation/#install-a-specific-branch-or-tag","title":"Install a Specific Branch or Tag","text":"<pre><code># Install from a specific branch\npip install \"ctrl-freeq @ git+https://github.com/mforoozandeh/ctrl-freeq.git@branch-name\"\n\n# Install from a specific tag\npip install \"ctrl-freeq @ git+https://github.com/mforoozandeh/ctrl-freeq.git@v0.1.0\"\n</code></pre>"},{"location":"installation/#editabledevelopment-install","title":"Editable/Development Install","text":"<p>For development or contributing purposes, the package may be installed in editable mode:</p> <pre><code>git clone https://github.com/mforoozandeh/ctrl-freeq.git\ncd ctrl-freeq\n\n# Using uv (recommended) \u2014 installs with all dependency group\nuv sync --all-groups\n\n# Or using pip \u2014 installs the package in editable mode (without dev dependencies)\npip install -e .\n</code></pre> <p>Dependency Groups</p> <p>Development dependencies (<code>pytest</code>, <code>jupyter</code>, etc.) are defined as dependency groups in <code>pyproject.toml</code>. These are installed via <code>uv sync --group dev</code>. It should be noted that the <code>pip install -e .[dev]</code> syntax does not support dependency groups.</p>"},{"location":"installation/#using-uv-recommended-package-manager","title":"Using uv (Recommended Package Manager)","text":"<p>As an alternative to pip, the uv package manager may be employed, which offers certain advantages in dependency resolution and environment management:</p> <pre><code># Install from PyPI\nuv pip install ctrl-freeq\n\n# Install pre-release\nuv pip install --prerelease=allow ctrl-freeq\n\n# Development install with dependency groups\ngit clone https://github.com/mforoozandeh/ctrl-freeq.git\ncd ctrl-freeq\nuv sync --all-groups\n</code></pre>"},{"location":"installation/#verify-the-installation","title":"Verify the Installation","text":""},{"location":"installation/#launch-the-gui","title":"Launch the GUI","text":"<pre><code>freeq-gui\n</code></pre> <p>If the command is found and the graphical interface window opens successfully, the installation is complete.</p>"},{"location":"installation/#verify-in-python","title":"Verify in Python","text":"<pre><code>from ctrl_freeq.api import CtrlFreeQAPI, load_single_qubit_config\n\n# Load a built-in example configuration\napi = load_single_qubit_config()\nprint(api.get_config_summary())\n</code></pre>"},{"location":"installation/#check-version","title":"Check Version","text":"<pre><code>import ctrl_freeq\nprint(ctrl_freeq.__version__)\n</code></pre>"},{"location":"installation/#upgrading","title":"Upgrading","text":""},{"location":"installation/#upgrade-to-latest-stable","title":"Upgrade to Latest Stable","text":"<pre><code>pip install --upgrade ctrl-freeq\n</code></pre>"},{"location":"installation/#upgrade-to-latest-pre-release","title":"Upgrade to Latest Pre-release","text":"<pre><code>pip install --upgrade --pre ctrl-freeq\n</code></pre>"},{"location":"installation/#gpu-support-optional","title":"GPU Support (Optional)","text":"<p>Ctrl-freeq supports GPU acceleration via the CUDA backend of PyTorch. To enable GPU support, the following steps should be followed:</p> <ol> <li>Ensure that a CUDA-compatible NVIDIA GPU is available</li> <li>Install PyTorch with CUDA support:</li> </ol> <pre><code># Example for CUDA 12.1\npip install torch --index-url https://download.pytorch.org/whl/cu121\n</code></pre> <ol> <li>Verify CUDA availability:</li> </ol> <pre><code>import torch\nprint(f\"CUDA available: {torch.cuda.is_available()}\")\nprint(f\"CUDA device: {torch.cuda.get_device_name(0) if torch.cuda.is_available() else 'N/A'}\")\n</code></pre> <p>A detailed treatment of GPU configuration is provided in Compute (CPU/GPU).</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#freeq-gui-command-not-found","title":"<code>freeq-gui</code> command not found","text":"<p>It should be verified that the package is installed and that the Python scripts directory is included in the system PATH:</p> <pre><code># Check if installed\npip show ctrl-freeq\n\n# Try running with python -m\npython -m ctrl_freeq.cli\n</code></pre>"},{"location":"installation/#import-errors","title":"Import errors","text":"<p>All dependencies may be reinstalled by upgrading the package:</p> <pre><code>pip install --upgrade ctrl-freeq\n</code></pre>"},{"location":"installation/#tkinter-not-available","title":"Tkinter not available","text":"<p>The GUI requires Tkinter, which may need to be installed separately on certain systems:</p> Ubuntu/DebianFedoramacOSWindows <pre><code>sudo apt-get install python3-tk\n</code></pre> <pre><code>sudo dnf install python3-tkinter\n</code></pre> <p>Tkinter is included with the Python distribution from python.org. If Homebrew is used: <pre><code>brew install python-tk@3.11  # adjust version to match your Python\n</code></pre></p> <p>Tkinter is included with the standard Python installer.</p>"},{"location":"installation/#cudagpu-issues","title":"CUDA/GPU issues","text":"<p>If GPU mode fails, the following steps may be taken:</p> <ol> <li>Verify the PyTorch CUDA installation: <code>python -c \"import torch; print(torch.cuda.is_available())\"</code></li> <li>Check CUDA driver compatibility with the installed PyTorch version</li> <li>Fall back to CPU mode by setting <code>compute_resource: \"cpu\"</code> in the configuration</li> </ol>"},{"location":"installation/#uninstalling","title":"Uninstalling","text":"<pre><code>pip uninstall ctrl-freeq\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference \u2014 Use ctrl-freeq programmatically</li> <li>GUI Guide \u2014 Configure and run optimization interactively</li> <li>Optimization Parameters \u2014 Understand configuration options</li> </ul>"},{"location":"optimization/","title":"Optimization","text":"<p>This section provides a comprehensive description of the optimization framework employed by ctrl-freeq. The numerical optimal control problem is solved using a variety of gradient-based and derivative-free algorithms, which are documented in detail alongside the configuration parameters governing the pulse design, quantum system specification, and computational resource allocation. For users of the graphical interface, the parameters described herein correspond directly to the configurable fields exposed in the GUI.</p> <ul> <li><code>Algorithms</code></li> <li><code>Parameters</code></li> <li><code>Compute (CPU/GPU)</code></li> </ul>"},{"location":"optimization/algorithms/","title":"Optimization Algorithms","text":"<p>Ctrl-freeq provides access to multiple optimization algorithms through the <code>algorithm</code> configuration field. These algorithms are drawn from two distinct families, each offering complementary capabilities for the solution of quantum control problems.</p>"},{"location":"optimization/algorithms/#algorithm-families","title":"Algorithm Families","text":"<p>The available algorithms are organized into two families. The first comprises gradient-based methods implemented via the pytorch-minimize library, which operates directly on PyTorch tensors and supports automatic differentiation for the computation of gradients and, where applicable, Hessians. The second family consists of wrapped Qiskit optimizers, identified by the <code>qiskit-</code> prefix, which include both gradient-based and derivative-free methods.</p>"},{"location":"optimization/algorithms/#built-in-algorithms","title":"Built-in Algorithms","text":"Algorithm Description <code>bfgs</code> Broyden-Fletcher-Goldfarb-Shanno (quasi-Newton) <code>l-bfgs</code> Limited-memory BFGS (lower memory usage) <code>cg</code> Conjugate gradient <code>newton-cg</code> Newton conjugate gradient <code>newton-exact</code> Newton with exact Hessian <code>dogleg</code> Dogleg trust-region <code>trust-ncg</code> Trust-region Newton-CG <code>trust-krylov</code> Trust-region with Krylov subspace <code>trust-exact</code> Trust-region with exact Hessian"},{"location":"optimization/algorithms/#qiskit-algorithms","title":"Qiskit Algorithms","text":"<p>The Qiskit optimizers are wrapped in <code>ctrl_freeq/optimizers/qiskit_optimizers.py</code>.</p> Algorithm Description <code>qiskit-cobyla</code> Constrained Optimization BY Linear Approximation <code>qiskit-nelder-mead</code> Nelder-Mead simplex (derivative-free) <code>qiskit-powell</code> Powell's method (derivative-free) <code>qiskit-slsqp</code> Sequential Least Squares Programming <code>qiskit-spsa</code> Simultaneous Perturbation Stochastic Approximation <code>qiskit-adam</code> Adam optimizer <code>qiskit-l-bfgs-b</code> L-BFGS-B with bounds <code>qiskit-tnc</code> Truncated Newton <code>qiskit-p-bfgs</code> Parallel L-BFGS-B <code>qiskit-gsls</code> Gaussian Smoothed Line Search <p>Note</p> <p>The exact set of available Qiskit optimizers is determined by the <code>get_supported_qiskit_optimizers()</code> function and may vary with the installed version.</p>"},{"location":"optimization/algorithms/#choosing-an-algorithm","title":"Choosing an Algorithm","text":"<p>The selection of an appropriate optimization algorithm depends on the characteristics of the problem at hand, the dimensionality of the parameter space, and the available computational resources.</p> <p>For general-purpose applications, the BFGS or L-BFGS algorithms provide reliable quasi-Newton methods that are well-suited to the majority of pulse design problems; the latter is particularly advantageous when the parameter space is large, owing to its reduced memory requirements. For smooth, well-behaved cost landscapes, the Newton-CG method often exhibits faster convergence due to its use of curvature information.</p> <p>In cases where derivative-free optimization is preferred or the problem involves constraints, COBYLA (<code>qiskit-cobyla</code>) offers a robust alternative that does not require gradient computation. For noisy or non-convex optimization landscapes, stochastic methods such as Adam (<code>qiskit-adam</code>) or SPSA (<code>qiskit-spsa</code>) may prove more effective, as they are designed to navigate irregular objective function surfaces.</p> <p>When high numerical precision is required and the computational cost of exact Hessian evaluation is acceptable, the <code>trust-exact</code> or <code>newton-exact</code> algorithms should be considered, as they exploit full second-order information to achieve rapid convergence in the neighbourhood of a minimum.</p>"},{"location":"optimization/algorithms/#convergence-parameters","title":"Convergence Parameters","text":"<p>The following parameters control the termination criteria of the optimization:</p> Parameter Description Default <code>max_iter</code> Maximum optimization iterations 1000 <code>targ_fid</code> Target fidelity threshold (stops when reached) 0.999"},{"location":"optimization/algorithms/#next-steps","title":"Next Steps","text":"<ul> <li>Parameters \u2014 Full configuration reference</li> <li>Compute (CPU/GPU) \u2014 Hardware acceleration options</li> </ul>"},{"location":"optimization/compute/","title":"Compute (CPU/GPU)","text":"<p>Ctrl-freeq supports the execution of optimization routines on both CPU and GPU hardware. The computational backend is selected through the <code>compute_resource</code> configuration field, which determines whether tensor operations are performed on the host processor or offloaded to a CUDA-compatible graphics processing unit.</p>"},{"location":"optimization/compute/#configuration","title":"Configuration","text":"<p>The compute resource is specified as a top-level field in the configuration:</p> <pre><code>{\n  \"compute_resource\": \"cpu\"\n}\n</code></pre> <p>Valid values:</p> <ul> <li><code>\"cpu\"</code> (default)</li> <li><code>\"gpu\"</code> (CUDA)</li> </ul>"},{"location":"optimization/compute/#cpu-configuration","title":"CPU Configuration","text":"<p>When the optimization is executed on CPU, thread allocation is managed automatically by the framework. By default, the number of PyTorch threads is set to one fewer than the total number of available CPU cores, thereby reserving one core for system responsiveness. This default behaviour may be overridden by specifying the <code>cpu_cores</code> field in the configuration, in which case the requested value is clamped to the interval [1, total_cores] to prevent invalid settings.</p> <pre><code>{\n  \"compute_resource\": \"cpu\",\n  \"cpu_cores\": 4\n}\n</code></pre>"},{"location":"optimization/compute/#gpu-configuration","title":"GPU Configuration","text":"<p>GPU acceleration requires a CUDA-enabled PyTorch installation and a compatible NVIDIA graphics processing unit.</p>"},{"location":"optimization/compute/#setup","title":"Setup","text":"<ol> <li>Ensure that a CUDA-compatible NVIDIA GPU is available</li> <li>Install PyTorch with CUDA support (see Installation)</li> <li>Set <code>compute_resource</code> to <code>\"gpu\"</code> in the configuration</li> </ol>"},{"location":"optimization/compute/#automatic-fallback","title":"Automatic Fallback","text":"<p>If GPU execution is requested but CUDA is not available on the host system, ctrl-freeq automatically falls back to CPU execution and emits a warning:</p> <pre><code>WARNING: CUDA not available; falling back to CPU. To use GPU, run on a CUDA-enabled environment.\n</code></pre> <p>This fallback mechanism ensures that optimization runs will always execute, regardless of the available hardware.</p>"},{"location":"optimization/compute/#verifying-gpu-availability","title":"Verifying GPU Availability","text":"<pre><code>import torch\nprint(f\"CUDA available: {torch.cuda.is_available()}\")\nif torch.cuda.is_available():\n    print(f\"CUDA device: {torch.cuda.get_device_name(0)}\")\n</code></pre>"},{"location":"optimization/compute/#gui","title":"GUI","text":"<p>The compute resource may also be selected from the Optimization Parameters &gt; Compute Resource dropdown in the graphical interface.</p>"},{"location":"optimization/compute/#api-usage","title":"API Usage","text":"<pre><code>from ctrl_freeq.api import load_single_qubit_config\n\napi = load_single_qubit_config()\n\n# Switch to GPU\napi.update_parameter(\"compute_resource\", \"gpu\")\n\n# Run optimization\nsolution = api.run_optimization()\n</code></pre>"},{"location":"optimization/compute/#next-steps","title":"Next Steps","text":"<ul> <li>Algorithms \u2014 Algorithm selection guide</li> <li>Parameters \u2014 Full configuration reference</li> <li>Installation \u2014 GPU setup instructions</li> </ul>"},{"location":"optimization/parameters/","title":"Optimization Parameters","text":"<p>Ctrl-freeq employs a JSON-based configuration schema that is shared between the programmatic API and the graphical user interface. This section provides a complete reference for all configurable parameters, organized by category.</p>"},{"location":"optimization/parameters/#configuration-schema","title":"Configuration Schema","text":"<p>The top-level structure of a configuration is as follows:</p> <pre><code>{\n  \"qubits\": [\"q1\", \"q2\"],\n  \"compute_resource\": \"cpu\",\n  \"parameters\": { ... },\n  \"initial_states\": [[\"Z\", \"Z\"]],\n  \"target_states\": { ... },\n  \"optimization\": { ... }\n}\n</code></pre> Field Description <code>qubits</code> List of qubit identifiers for display and indexing <code>compute_resource</code> <code>\"cpu\"</code> or <code>\"gpu\"</code> (see Compute)"},{"location":"optimization/parameters/#system-parameters","title":"System Parameters","text":"<p>The system parameters define the physical properties of the quantum system under consideration. All values are specified as per-qubit arrays, with one entry for each qubit in the configuration.</p> Key GUI Label Description Default Units <code>Delta</code> \u0394 (Hz) Detuning frequency 10 MHz Hz <code>sigma_Delta</code> \u03c3\u0394 (Hz) Detuning uncertainty (for robustness) 0 Hz <code>Omega_R_max</code> \u03a9_R Max (Hz) Maximum Rabi frequency 40 MHz Hz <code>sigma_Omega_R_max</code> \u03c3\u03a9_R Max (Hz) Rabi frequency uncertainty 0 Hz"},{"location":"optimization/parameters/#pulse-parameters","title":"Pulse Parameters","text":"<p>The pulse parameters control the temporal characteristics of the control waveform, including its duration, discretization, and frequency properties. As with the system parameters, all values are per-qubit arrays.</p> Key GUI Label Description Default Units <code>pulse_duration</code> Pulse Duration (sec) Total pulse length 200 ns seconds <code>point_in_pulse</code> Point in Pulse Time discretization points 100 \u2014 <code>sw</code> Sweep Rate (Hz) Frequency sweep rate 5 MHz Hz <code>pulse_offset</code> Pulse Offset (Hz) Frequency offset 0 Hz <code>pulse_bandwidth</code> Pulse Bandwidth (Hz) Pulse frequency bandwidth 500 kHz Hz"},{"location":"optimization/parameters/#waveform-settings","title":"Waveform Settings","text":"<p>The waveform settings determine the basis functions and envelope used to parameterize the control pulse. The choice of basis and mode has a significant influence on the smoothness, bandwidth, and convergence properties of the optimized waveform. All values are per-qubit arrays.</p> Key GUI Label Options Default Description <code>wf_type</code> Waveform Type See below <code>cheb</code> Basis function type <code>wf_mode</code> Waveform Mode <code>cart</code>, <code>polar</code>, <code>polar_phase</code> <code>cart</code> Cartesian or polar representation <code>amplitude_envelope</code> Amplitude Envelope <code>gn</code>, <code>rect</code>, <code>sinc</code> <code>gn</code> Pulse envelope shape <code>amplitude_order</code> Amplitude Order Integer 1 Envelope order parameter <code>coverage</code> Coverage <code>single</code>, <code>broadband</code>, <code>selective</code>, <code>band_selective</code> <code>single</code> Frequency coverage mode <code>profile_order</code> Profile Order Integer 2 Supergaussian order for selectivity profile (1 = Gaussian, higher values \u2192 more rectangular) <code>n_para</code> Number of Parameters Integer 16 Optimization parameters per qubit <p>Waveform Types</p> <p>Several families of orthogonal basis functions are available for the parameterization of the control waveform:</p> <ul> <li>cheb \u2014 Chebyshev polynomial basis (recommended for most applications due to favourable convergence properties)</li> <li>fou \u2014 Fourier series basis</li> <li>poly \u2014 Standard polynomial basis</li> <li>leg \u2014 Legendre polynomial basis</li> <li>hermite \u2014 Hermite polynomial basis</li> <li>gegen \u2014 Gegenbauer polynomial basis</li> <li>chirp \u2014 Chirp basis</li> </ul> <p>Waveform Modes</p> <p>The waveform representation may be specified in one of three modes:</p> <ul> <li>cart \u2014 Cartesian mode, in which the in-phase (I) and quadrature (Q) components are optimized independently</li> <li>polar \u2014 Polar mode, in which the amplitude and phase are optimized directly</li> <li>polar_phase \u2014 Polar phase mode, in which only the phase is optimized while the amplitude profile remains fixed</li> </ul>"},{"location":"optimization/parameters/#dissipation-parameters","title":"Dissipation Parameters","text":"<p>For the simulation of open quantum systems, ctrl-freeq supports dissipative dynamics via the Lindblad master equation. When dissipation is enabled, the evolution includes amplitude damping (characterised by the longitudinal relaxation time T1) and pure dephasing (characterised by the transverse relaxation time T2) for each qubit. All values are per-qubit arrays, with one entry for each qubit in the configuration.</p> Key GUI Label Description Default Units <code>T1</code> T1 (s) Amplitude damping time constant (energy relaxation) \u2014 seconds <code>T2</code> T2 (s) Pure dephasing time constant (phase decoherence) \u2014 seconds <p>The Lindblad collapse operators constructed from these parameters are:</p> <ul> <li>Amplitude damping: $L_1 = \\sqrt{1/T_1}\\, \\sigma^-$ \u2014 models energy relaxation to the ground state</li> <li>Pure dephasing: $L_2 = \\sqrt{1/T_2 - 1/(2T_1)}\\, \\sigma_z/2$ \u2014 models loss of phase coherence without energy exchange</li> </ul> <p>For multi-qubit systems, the collapse operators are extended to the full Hilbert space via tensor products with identity operators on the remaining qubits.</p> <p>Physical Constraint</p> <p>The physical constraint $T_2 \\leq 2 T_1$ is enforced automatically. Configurations that violate this bound will raise a validation error, as such values are unphysical (the pure dephasing rate cannot be negative).</p> <p>Liouville Space Requirement</p> <p>Dissipative simulations require the optimization space to be set to <code>liouville</code> (density matrix mode). When <code>dissipation_mode</code> is set to <code>\"dissipative\"</code>, the space is automatically forced to <code>liouville</code> in the GUI.</p> <p>Example:</p> <pre><code>{\n  \"parameters\": {\n    // ... other parameters ...\n    \"T1\": [0.001],       // 1 ms amplitude damping\n    \"T2\": [0.0005]       // 500 \u03bcs pure dephasing (T2 \u2264 2\u00b7T1)\n  },\n  \"optimization\": {\n    \"space\": \"liouville\",\n    \"dissipation_mode\": \"dissipative\",\n    // ...\n  }\n}\n</code></pre>"},{"location":"optimization/parameters/#multi-qubit-coupling","title":"Multi-Qubit Coupling","text":"<p>For systems comprising two or more qubits, the inter-qubit coupling parameters must be specified. These fields are used when <code>len(qubits) &gt; 1</code>:</p> Key GUI Label Description Default <code>J</code> J_ij Coupling matrix (N\u00d7N), symmetric ~16.7 MHz <code>coupling_type</code> Coupling Type <code>Z</code>, <code>XY</code>, or <code>XYZ</code> <code>XY</code> <code>sigma_J</code> \u03c3 J Coupling strength uncertainty 0 <p>Coupling Types</p> <p>Three coupling models are supported, corresponding to common interaction Hamiltonians encountered in quantum information processing:</p> <ul> <li>Z \u2014 Ising-type ZZ coupling only</li> <li>XY \u2014 XX + YY exchange coupling (default)</li> <li>XYZ \u2014 Full Heisenberg coupling (XX + YY + ZZ)</li> </ul>"},{"location":"optimization/parameters/#initial-states","title":"Initial States","text":"<p>The initial state of each qubit is specified as a list of Bloch sphere axis labels. For multi-qubit systems, each entry in the outer list corresponds to a distinct initial configuration of the entire register.</p> <pre><code>// Single qubit\n{ \"initial_states\": [[\"Z\"]] }\n\n// Two qubits\n{ \"initial_states\": [[\"Z\", \"Z\"]] }\n</code></pre>"},{"location":"optimization/parameters/#target-states","title":"Target States","text":"<p>The desired final state or gate may be specified using one of three methods, each suited to different use cases.</p>"},{"location":"optimization/parameters/#axis-targets","title":"Axis Targets","text":"<p>The target state is specified as a Bloch sphere axis direction.</p> <pre><code>{ \"target_states\": { \"Axis\": [[\"-Z\"]] } }\n</code></pre> Value Description <code>Z</code> Ground state (|0\u27e9) <code>-Z</code> Excited state (|1\u27e9) <code>X</code>, <code>-X</code> Superposition along \u00b1X <code>Y</code>, <code>-Y</code> Superposition along \u00b1Y"},{"location":"optimization/parameters/#gate-targets","title":"Gate Targets","text":"<p>The target is specified as a quantum gate, which implicitly defines the required unitary transformation.</p> <pre><code>{ \"target_states\": { \"Gate\": [\"X\", \"H\", \"CNOT\"] } }\n</code></pre> <p>Single-qubit: <code>X</code>, <code>Y</code>, <code>Z</code>, <code>H</code>, <code>S</code>, <code>T</code></p> <p>Two-qubit: <code>CNOT</code>, <code>CZ</code>, <code>SWAP</code>, <code>iSWAP</code></p> <p>Three-qubit: <code>Toff</code> (Toffoli)</p>"},{"location":"optimization/parameters/#phibeta-targets","title":"Phi/Beta Targets","text":"<p>The target rotation is specified in terms of the rotation axis and angle.</p> <pre><code>{ \"target_states\": { \"Phi\": [\"x\"], \"Beta\": [\"180\"] } }\n</code></pre> Parameter Description Range Phi (\u03c6) Rotation axis in XY plane <code>x</code>, <code>y</code>, or angle in degrees Beta (\u03b2) Rotation angle 0\u00b0 \u2013 360\u00b0"},{"location":"optimization/parameters/#multi-state-optimization","title":"Multi-State Optimization","text":"<p>Ctrl-freeq supports the simultaneous optimization of pulses for multiple initial/target state pairs. This capability is essential for the design of universal rotation pulses (in the single-qubit case) and conditional gates such as CNOT or SWAP (in the multi-qubit case). The optimizer seeks a single pulse that achieves all specified state transformations concurrently.</p>"},{"location":"optimization/parameters/#single-qubit-example-universal-rotation","title":"Single-Qubit Example: Universal Rotation","text":"<p>To design a pulse that performs a universal rotation, multiple initial-to-target state mappings are specified:</p> <pre><code>{\n  \"initial_states\": [[\"X\"], [\"Y\"], [\"Z\"]],\n  \"target_states\": {\n    \"Axis\": [[\"X\"], [\"Z\"], [\"-Y\"]]\n  }\n}\n</code></pre> <p>The optimization then seeks a single pulse that simultaneously achieves the following transformations:</p> Initial Target Transformation X X X axis preserved Y Z Y \u2192 Z rotation Z -Y Z \u2192 -Y rotation"},{"location":"optimization/parameters/#multi-qubit-example-conditional-gates","title":"Multi-Qubit Example: Conditional Gates","text":"<p>For two-qubit systems, multiple state pairs may be specified to design conditional gates:</p> <pre><code>{\n  \"initial_states\": [[\"Z\", \"-Z\"], [\"X\", \"Y\"]],\n  \"target_states\": {\n    \"Gate\": [\"CNOT\", \"SWAP\"]\n  }\n}\n</code></pre> <p>State Pair Matching</p> <p>It should be noted that the number of initial states must equal the number of target states. Each initial state at index <code>i</code> is mapped to the target state at the corresponding index.</p>"},{"location":"optimization/parameters/#gui-usage","title":"GUI Usage","text":"<p>In the graphical interface, multiple states are entered as comma-separated values:</p> <ul> <li>Initial States: <code>X, Y, Z</code></li> <li>Target Axis: <code>X, Z, -Y</code></li> </ul> <p>For two-qubit systems, semicolons are used to separate qubits within each state pair.</p>"},{"location":"optimization/parameters/#api-usage","title":"API Usage","text":"<pre><code>from ctrl_freeq.api import load_single_qubit_multiple_config\n\n# Load pre-configured multi-state example\napi = load_single_qubit_multiple_config()\nsolution = api.run_optimization()\n</code></pre> <p>Available multi-state configurations:</p> Function Description <code>load_single_qubit_multiple_config()</code> Single qubit with X,Y,Z \u2192 X,Z,-Y <code>load_two_qubit_multiple_config()</code> Two qubits with multiple gate targets"},{"location":"optimization/parameters/#optimization-settings","title":"Optimization Settings","text":"<p>The following fields control the behaviour of the optimization procedure:</p> Key GUI Label Description Default <code>space</code> Space <code>hilbert</code> (pure states) or <code>liouville</code> (density matrices) <code>hilbert</code> <code>dissipation_mode</code> Dissipation <code>non-dissipative</code> or <code>dissipative</code> (Lindblad master equation) <code>non-dissipative</code> <code>H0_snapshots</code> H\u2080 Snapshots Time steps for drift Hamiltonian 100 <code>Omega_R_snapshots</code> \u03a9_R Snapshots Time steps for control Hamiltonian 1 <code>algorithm</code> Algorithm Optimization algorithm (see Algorithms) varies by config <code>max_iter</code> Max Iterations Maximum optimization iterations 1000 <code>targ_fid</code> Target Fidelity Stop when fidelity reaches this value 0.999"},{"location":"optimization/parameters/#next-steps","title":"Next Steps","text":"<ul> <li>Algorithms \u2014 Algorithm selection guide</li> <li>Compute (CPU/GPU) \u2014 Hardware acceleration options</li> <li>GUI Guide \u2014 Interactive configuration</li> </ul>"}]}